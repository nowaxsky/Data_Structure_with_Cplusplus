1. &參考不是取址:
參考變數等同被參考變數之別名, 類似該變數有兩個名稱, 任一修改都會影響.
優點為不會額外配置記憶體.

2. 左值右值(p.25):
右值不可取址, 也不可參考右值,
i.e, int &v = 5; //error
但右值可以作為固定值參考如下:
const int &v = 5;
可思考為v不能再重新賦值, 若v=10, 10!=5會出錯, 故const表明不能再賦值.

3. 將變數傳遞進去函式作為參數時, 是複製一個變數, 回傳時是右值(p.27).
4. 函式傳址(p.30): 可以傳遞變數本體進去函數, 直接計算且節省空間.
5. 函式傳參考(p.31): 基本同傳址, 但注意若沒有回傳參考&將無法再賦值.
p.31中若int &Addone寫成int Addone會造成main中Addone(a) = 0錯誤,
原因是沒有&則回傳一個暫時變數(右值)自然不能賦值,
但如果有&則回傳v本身(a的別名)為左值, 可賦值.

6. 有時用參考型態是為了節省空間, 並非為了修改本體(p.33).
7. 函數中若有函數要當作參數, 必須使用固定值參考並不能用一般參考(理由見2).
8. 回傳值為類別型態時可用const將其回傳值固定, 
避免再對回傳類別(右值)修改變數而沒有產生編譯錯誤的問題.

9. 類別中const成員函式: (注意const放置位置)
可使用const修飾成員函式, 表示呼叫該成員函式時不會修改到物件內容(p.36).
故const物件只能呼叫const成員函式, 不能呼叫non-const成員函式.(見Note4中4)
non-const則均可呼叫.

10. 建構式: (i.e, Grade 類別)
a. Grade a; 會呼叫無參數之建構式, 若類別中無此建構式,
則自動定義與呼叫空白建構式: Grade(){};
注意: 如果類別中已有定義有其他建構式, 將不會自動產生空白建構式,
若無定義Grade()建構式而使用Grade a; 將會導致錯誤.

b. 可以產生暫時物件, Grade(); //會呼叫建構式.
c. 可用暫時物件初始化物件, Grade b = Grade();
d. 宣告物件陣列時也會呼叫建構式, Grade c[3]; //會呼叫建構式Grade()3次.
e. 呼叫有參數的建構式, Grade d(10); //呼叫Grade(int n).
f. 可產生帶有參數的暫時物件, Grade(10); 
g. 產生物件陣列時只能呼叫無參數建構式(p.48).
h. 隱性轉型: Grade e=10; //呼叫Grade(int n)建構式.
注意: 沒特殊理由的話, 單一參數之建構式盡量避免隱性轉型(見Note4)

i. 隱性轉型可以用在引數, 回傳(p.49), 注意下面狀況:
Grade a;
a = 10; //10會隱性轉型為Grade(10)後複製到Grade a;

j. 解構式不能帶有參數(建構式可). 

11.(???) 不知道p.56 operator前方的參考意義為何?有時有, 有時沒有(見Note4中5).
12.(???) 多載前方的const目前理解為不能改變暫時物件所設(同8).
13. 輸入輸出多載: 參考p.60和stream.cpp




