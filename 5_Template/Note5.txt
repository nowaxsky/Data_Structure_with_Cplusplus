1. 模板參數在可從函式參數判斷模板參數的情況下可省略(p.6):
int a=3, b=5;
double c=3.5;
swap(a,b); //可接受, 意義等同swap<int>(a,b)或swap<>(a,b).

2. 類別模板:(p.8, i.e, class Grade)
定義模板的成員函式時很多時候可省略模板參數, 但避免混淆可完整寫出.
建構式名稱依然為Grade而非Grade<T>.
Grade(const T &v)使用const和&主要是能給予複製建構式使用(見Note4中7).

3. p.9中類別模板之At函數與之前的定義方式不同須注意:
ElemType &At(int i);
const ElemType &At(int i) const; 
前者相同, 後者目前理解為節省空間, 由於回傳有可能為物件,
使用&為淺複製, 但為了避免再給其賦值, 再加上const.
經測試ElemType At(int i) const; 依然沒問題.
唯一不同的是, 此處多載之<<中,
採用const Array<ElemType, kNumOfElems> &rhs傳參考,
此時為傳入一個常數物件, 故會直接呼叫後者.

4. 若陣列大小在編譯期可決定的話, 可寫進模板, 並省略大三法則.
不用解構式: 無配置動態記憶體.
不用複製建構式: 物件本身不需要任何參數(模板才需要參數).
不用賦值運算子: 賦值前須先宣告模板參數, 此時已經完全複製了.

5.(???) static前綴全域變數時等同namespace, 表示就只有此檔案可使用(p.11).
6. static前綴區域變數時, 在整個程式中只會建構一次,並在程式結束時消失.
此時該函數(含有static之區域變數)可回傳參考, 使其可賦值(p.12).

7. static可修飾類別成員(變數和函式), 使其並非個別物件所屬, 而是該類別所屬.
可直接讀取變數或函式(須放在public)而不必建立物件.
注意: 此類變數或函式可不建立物件即產生, 故不能存取一般物件成員,
可以加上const成為static const並賦予固定右值來修飾.
另一種方式則使用模板參數來初始化(見array_3.cpp), 則可不必const.
